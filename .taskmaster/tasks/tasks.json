{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Chrome Extension Foundation",
        "description": "Set up the basic Chrome extension structure with Manifest V3, TypeScript, and React for the LearnSphere project.",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "details": "Create the foundational Chrome extension structure including:\n- Manifest V3 configuration\n- TypeScript setup with proper configuration\n- React integration for UI components\n- Basic folder structure (src/, public/, etc.)\n- Development environment setup with hot reloading\n- Basic extension popup and content script structure",
        "testStrategy": "Verify extension loads in Chrome, popup opens, and content scripts can be injected into PDF pages."
      },
      {
        "id": 2,
        "title": "PDF Viewer Integration and Override",
        "description": "Integrate with Chrome's PDF viewer to override default behavior and inject LearnSphere functionality.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          1
        ],
        "details": "Implement PDF viewer integration:\n- Override Chrome's default PDF viewer for both web URLs and local files\n- Integrate PDF.js for accurate rendering and layout preservation\n- Ensure multimodal elements (diagrams, charts, equations) are properly rendered\n- Set up content script injection into PDF pages\n- Handle both online and offline PDF access",
        "testStrategy": "Test with various PDF types (text-heavy, image-heavy, mixed content) and verify proper rendering and script injection."
      },
      {
        "id": 3,
        "title": "Document Processing and RAG Indexing",
        "description": "Implement document processing pipeline for PDF content extraction and RAG indexing using Vertex AI.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          2
        ],
        "details": "Build document processing system:\n- Extract text content from PDF pages\n- Implement OCR for scanned documents if necessary\n- Extract multimodal elements (images, diagrams, charts)\n- Create embeddings using Vertex AI Vector Search\n- Index content for efficient retrieval\n- Implement document metadata storage",
        "testStrategy": "Process various PDF types and verify accurate content extraction and indexing."
      },
      {
        "id": 4,
        "title": "Text Selection and Highlighting Interface",
        "description": "Implement text selection and highlighting functionality for user interaction with PDF content.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          2
        ],
        "details": "Create text selection interface:\n- Enable text highlighting on PDF pages\n- Implement selection event handling\n- Create visual feedback for selected text\n- Store selection coordinates and content\n- Handle multi-page selections\n- Ensure compatibility with PDF.js rendering",
        "testStrategy": "Test text selection across different PDF layouts and verify accurate content capture."
      },
      {
        "id": 5,
        "title": "Contextual Chat Sidebar UI",
        "description": "Design and implement the chat sidebar interface for LearnSphere interactions.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          4
        ],
        "details": "Build chat sidebar component:\n- Create collapsible sidebar UI\n- Implement chat message interface\n- Add input field for user questions\n- Display conversation history\n- Show selected content context\n- Implement loading states and error handling\n- Ensure responsive design for different screen sizes",
        "testStrategy": "Test sidebar functionality, chat interface, and responsive behavior across different devices."
      },
      {
        "id": 6,
        "title": "AI Integration with Gemini API",
        "description": "Integrate Google Gemini API for AI-powered responses with strict RAG implementation.",
        "status": "done",
        "priority": "critical",
        "dependencies": [
          3,
          5
        ],
        "details": "Implement AI integration:\n- Set up Vertex AI client for Gemini access\n- Implement strict RAG to constrain responses to PDF content only\n- Create prompt engineering for accurate, grounded responses\n- Handle API rate limiting and error cases\n- Implement streaming responses for better UX\n- Add authentication for API access\n- Ensure secure data transmission",
        "testStrategy": "Test AI responses with various PDF content and verify strict adherence to source material."
      },
      {
        "id": 7,
        "title": "Study Aid Generation - Summaries",
        "description": "Implement summary generation functionality for different scopes (page, chapter, document).",
        "status": "done",
        "priority": "high",
        "dependencies": [
          6
        ],
        "details": "Build summary generation:\n- Implement scope selection (Current Page, Selected Chapter, Entire Document)\n- Generate brief and detailed summary options\n- Use Gemini API for content analysis\n- Ensure summaries are grounded in PDF content\n- Add export functionality for summaries\n- Implement progress indicators during generation",
        "testStrategy": "Generate summaries for various PDF types and verify accuracy and relevance."
      },
      {
        "id": 8,
        "title": "Study Aid Generation - Multiple Choice Quizzes",
        "description": "Implement MCQ generation with challenging questions and plausible distractors.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          6
        ],
        "details": "Create quiz generation system:\n- Generate multiple choice questions from PDF content\n- Create plausible distractors using AI\n- Implement quiz interface with scoring\n- Add immediate feedback for answers\n- Track quiz results locally\n- Support different difficulty levels\n- Ensure questions are grounded in source material",
        "testStrategy": "Generate quizzes for various topics and verify question quality and answer accuracy."
      },
      {
        "id": 9,
        "title": "Local Database Implementation with IndexedDB",
        "description": "Implement local database using IndexedDB for storing learning analytics and user data.",
        "status": "done",
        "priority": "critical",
        "dependencies": [
          7,
          8
        ],
        "details": "Set up local database:\n- Implement IndexedDB using Dexie.js wrapper\n- Design database schema for learning analytics\n- Store quiz results, scores, and missed questions\n- Track contextual chat query topics\n- Implement data persistence and retrieval\n- Add database migration capabilities\n- Ensure data integrity and error handling",
        "testStrategy": "Test database operations, data persistence, and performance with various data loads."
      },
      {
        "id": 10,
        "title": "Local Knowledge Gap Analysis",
        "description": "Implement client-side analysis to identify user knowledge gaps and learning patterns.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          9
        ],
        "details": "Build knowledge gap analysis:\n- Analyze quiz performance data locally\n- Identify consistently missed topics/keywords\n- Track learning progress over time\n- Generate personalized insights\n- Create topic difficulty assessments\n- Implement learning pattern recognition\n- Ensure privacy by keeping analysis local",
        "testStrategy": "Test analysis accuracy with sample data and verify privacy compliance."
      },
      {
        "id": 11,
        "title": "Personalized Dashboard UI",
        "description": "Create a dashboard for users to view learning statistics and identified knowledge gaps.",
        "status": "done",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "details": "Design and implement dashboard:\n- Create dashboard layout and navigation\n- Display learning statistics and progress\n- Show identified knowledge gaps\n- Implement data visualization components\n- Add export functionality for learning data\n- Ensure responsive design\n- Integrate with local database for real-time data",
        "testStrategy": "Test dashboard functionality, data display accuracy, and responsive behavior.",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Dashboard Layout and Navigation",
            "description": "Create the overall dashboard structure, including layout, navigation, and section organization to ensure a clear visual hierarchy and intuitive user flow.",
            "dependencies": [],
            "details": "Analyze user needs and dashboard goals to determine the most important information to display. Use wireframes to map out the dashboard layout, grouping related data into panels or sections (e.g., learning statistics, knowledge gaps). Design navigation elements for easy access to different dashboard areas. Apply best practices for visual hierarchy, spacing, and accessibility to guide user attention and ensure usability.",
            "status": "done",
            "testStrategy": "Review wireframes with stakeholders and conduct usability walkthroughs to validate layout clarity and navigation flow."
          },
          {
            "id": 2,
            "title": "Implement Data Integration and Real-Time Updates",
            "description": "Connect the dashboard UI to the local database to fetch and display up-to-date learning statistics and knowledge gap data.",
            "dependencies": [
              "11.1"
            ],
            "details": "Develop data fetching logic to retrieve user learning statistics and identified knowledge gaps from the local database. Implement state management to ensure the dashboard reflects real-time data changes. Handle loading, error, and empty states gracefully. Ensure data privacy and integrity by following client-side data handling best practices.",
            "status": "done",
            "testStrategy": "Test with sample user data to verify correct retrieval, display, and real-time updates of dashboard information."
          },
          {
            "id": 3,
            "title": "Develop Data Visualization Components",
            "description": "Create and integrate visual components (charts, graphs, progress bars) to represent learning statistics and knowledge gaps in an easily digestible format.",
            "dependencies": [
              "11.2"
            ],
            "details": "Select appropriate visualization libraries (e.g., Chart.js, Recharts) and design visual components for key metrics such as progress over time, topic mastery, and knowledge gaps. Ensure visualizations are clear, accessible, and responsive. Integrate these components into the dashboard sections, using color and typography to emphasize critical insights.",
            "status": "done",
            "testStrategy": "Validate visualizations with various data sets for accuracy, clarity, and responsiveness across devices."
          },
          {
            "id": 4,
            "title": "Add Export and Responsive Functionality",
            "description": "Implement features for exporting learning data and ensure the dashboard is fully responsive across devices.",
            "dependencies": [
              "11.3"
            ],
            "details": "Develop export options (e.g., CSV, PDF) for users to download their learning statistics and knowledge gap reports. Test export functionality for data completeness and formatting. Apply responsive design techniques (flexbox, media queries) to ensure the dashboard layout and visualizations adapt seamlessly to different screen sizes and orientations.",
            "status": "done",
            "testStrategy": "Test export features for accuracy and usability. Use device emulators and real devices to verify responsive behavior and layout integrity."
          }
        ]
      },
      {
        "id": 12,
        "title": "Customized Revision Plan Generation",
        "description": "Implement system to generate proactive revision suggestions based on knowledge gap analysis.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          10,
          11
        ],
        "details": "Build revision planning system:\n- Generate targeted revision suggestions\n- Link suggestions to specific PDF sections\n- Create personalized study recommendations\n- Implement revision plan tracking\n- Add progress monitoring for revision activities\n- Ensure suggestions are actionable and specific\n- Integrate with quiz system for targeted practice",
        "testStrategy": "Test revision plan generation and verify effectiveness in improving learning outcomes."
      },
      {
        "id": 13,
        "title": "Extension Configuration and Settings",
        "description": "Implement user settings and configuration options for the LearnSphere extension.",
        "status": "done",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "details": "Create settings interface:\n- Add extension popup with settings\n- Implement user preferences storage\n- Add configuration for AI model selection\n- Create privacy and data management options\n- Add export/import functionality for user data\n- Implement theme and UI customization\n- Add help and documentation access",
        "testStrategy": "Test settings persistence, configuration options, and user preference management."
      },
      {
        "id": 14,
        "title": "Error Handling and User Feedback",
        "description": "Implement comprehensive error handling and user feedback mechanisms throughout the extension.",
        "status": "done",
        "priority": "medium",
        "dependencies": [
          6,
          9
        ],
        "details": "Build error handling system:\n- Implement graceful error handling for API failures\n- Add user-friendly error messages\n- Create loading states and progress indicators\n- Implement retry mechanisms for failed operations\n- Add offline mode handling\n- Create error logging and reporting\n- Ensure consistent error messaging across features",
        "testStrategy": "Test error scenarios, user feedback, and recovery mechanisms."
      },
      {
        "id": 15,
        "title": "Testing and Quality Assurance",
        "description": "Implement comprehensive testing suite for all LearnSphere functionality.",
        "status": "done",
        "priority": "high",
        "dependencies": [
          12,
          13,
          14
        ],
        "details": "Create testing framework:\n- Implement unit tests for core functionality\n- Add integration tests for AI interactions\n- Create end-to-end tests for user workflows\n- Test with various PDF types and content\n- Implement performance testing\n- Add accessibility testing\n- Create automated testing pipeline",
        "testStrategy": "Run comprehensive test suite and verify all functionality works as expected."
      },
      {
        "id": 16,
        "title": "Chrome Extension Framework Setup",
        "description": "Initialize the Chrome Extension project using Manifest V3, TypeScript, and React. Establish the base structure for extension lifecycle, permissions, and UI mounting.",
        "details": "Create the extension manifest (v3), configure TypeScript and React, set up webpack or Vite for bundling, and scaffold the popup and sidebar components. Ensure permissions for file access, clipboard, and storage are declared.",
        "testStrategy": "Verify extension loads in Chrome, UI mounts correctly, and permissions are recognized. Run unit tests for initialization logic.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Universal Content Extraction & Anchoring (with optional PDF.js fallback)",
        "description": "Provide robust content extraction and stable anchoring on any web page (HTML), with optional, lazy-loaded PDF.js fallback only when encountering PDFs that block injection or require page/coordinate precision.",
        "status": "pending",
        "dependencies": [
          16
        ],
        "priority": "high",
        "details": "Implement a universal extraction and anchoring system:\n\n- For HTML pages:\n  - Extract main readable content and per-selection snippets, preserving basic structure.\n  - Serialize selections (Range → XPath/TextPosition) to create stable anchors that persist and re-highlight across revisits.\n  - On revisit, re-apply highlights for saved anchors.\n  - Store context chunks and anchors in IndexedDB, keyed by URL + anchorId, deduplicated by hash.\n  - Integrate with RAG: when chatting, include anchored snippet(s) nearest the user’s selection, cite original location, and provide a scroll-back link.\n  - If an <img> is selected, capture src/alt and bounding rect metadata; include as multimodal context.\n  - Gracefully degrade to cached snippets if offline; no network calls in offline mode.\n\n- For PDFs (fallback path):\n  - Detect PDF URLs/content-types or failed content script injection (native viewer/restricted).\n  - Prompt user with 'Open with LearnSphere viewer' when fallback is needed.\n  - Lazy-load PDF.js viewer in an internal page with the PDF URL; provide page/coordinate-level selection overlay.\n  - Store PDF anchors as page number + text range or bounding boxes; cite 'Page X' in responses and support re-highlight.\n  - PDF.js and related assets are loaded only when needed to keep the bundle lean.\n\n- Non-functional:\n  - Maintain MV3 constraints; no injection in restricted pages.\n  - Keep content bundle size stable; PDF.js is dynamically imported or loaded in a separate entry page.\n  - Respect privacy mode; anchors/snippets remain local.\n<info added on 2025-08-17T18:34:03.114Z>\nAcceptance Criteria:\n\n17.1 Implement HTML Content Extraction and Anchoring\n- Selecting text and saving creates an anchor with Range serialization (XPath/TextPosition)\n- Reloading the page re-applies a highlight at the exact location\n- Anchors stored in IndexedDB: {url, anchorId, method, serialized, snippet, hash, createdAt}\n\n17.2 Integrate RAG with Anchored Snippets\n- Chat requests include nearest anchor snippet(s)\n- Assistant replies show a citation with a scroll-back link that focuses the anchor\n- If no anchor exists, falls back to current selection text\n\n17.3 Image Selection Metadata Capture\n- Selecting an <img> stores {src, alt, naturalWidth/Height, boundingClientRect}\n- Multimodal chat includes image data when permitted\n- Preview chip shows a thumbnail and can be removed\n\n17.4 Offline Mode and Caching\n- With navigator.onLine=false, chat still shows cached snippets\n- No network calls are attempted; UI shows offline banner\n- When going back online, normal behavior resumes\n\n17.5 PDF Fallback Detection and Prompt\n- PDFs in native viewer trigger a prompt: \"Open with LearnSphere viewer\"\n- Choosing open launches internal viewer page with the PDF URL appended\n\n17.6 Lazy-load PDF.js Viewer and Anchoring\n- PDF viewer loads only upon request (dynamic import or separate entry)\n- Page/coordinate selection overlay works; anchors include {page, bbox or textRange}\n- Re-opening the same PDF re-highlights saved anchors\n\n17.7 IndexedDB Anchor Storage and Deduplication\n- Duplicate anchors (same url+hash) are not duplicated\n- List/inspect shows unique anchors with timestamps\n\n17.8 Bundle Size and Privacy Constraints\n- content.js size remains within current range; no added runtime chunks\n- PDF viewer assets only fetched when viewer is opened\n- Privacy mode prevents anchors/snippets from leaving local storage\n</info added on 2025-08-17T18:34:03.114Z>",
        "testStrategy": "1. On any HTML page, select text and save or ask a question; verify that an anchor is created, re-highlights on reload, and is visible in chat citations.\n2. Simulate offline mode and confirm cached snippets are shown with no network calls.\n3. On a PDF in the native viewer, verify the user is offered 'Open with LearnSphere viewer'; opening provides page/coordinate selection and chat cites the page.\n4. Inspect IndexedDB to confirm anchor records are keyed by URL + anchorId, contain snippet text, serialization, and timestamps, and are deduplicated by hash.\n5. Confirm that bundle size impact is limited to optional viewer assets and content.js remains single-file and light.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement HTML Content Extraction and Anchoring",
            "description": "Develop logic to extract main content and per-selection snippets from HTML pages. Serialize selections to stable anchors (XPath/TextPosition), store in IndexedDB, and support re-highlighting on revisit.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Integrate RAG with Anchored Snippets",
            "description": "When user chats, include the anchored snippet(s) nearest their selection, cite the original location, and provide a scroll-back link in the chat UI.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Image Selection Metadata Capture",
            "description": "When an <img> element is selected, capture src/alt and bounding rect metadata, and include as multimodal context for extraction and RAG.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Offline Mode and Caching",
            "description": "Implement offline fallback: serve cached snippets and anchors from IndexedDB when offline; ensure no network calls are made.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "PDF Fallback Detection and Prompt",
            "description": "Detect when a PDF is encountered (by URL/content-type or failed injection) and prompt the user with 'Open with LearnSphere viewer'.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Lazy-load PDF.js Viewer and Anchoring",
            "description": "Implement internal page to lazy-load PDF.js viewer with the PDF URL. Provide page/coordinate-level selection overlay and anchor storage (page number + text range or bounding box). Support re-highlighting and citation as 'Page X'.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "IndexedDB Anchor Storage and Deduplication",
            "description": "Ensure all anchors and context chunks are stored in IndexedDB, keyed by URL + anchorId, deduplicated by hash, and include snippet text, serialization, and timestamps.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Bundle Size and Privacy Constraints",
            "description": "Verify that PDF.js and related assets are only loaded when needed, content.js remains single-file and light, and all anchors/snippets remain local in privacy mode.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "Document Processing and RAG Indexing",
        "description": "Process opened PDFs for multimodal extraction and index content for Retrieval Augmented Generation (RAG).",
        "details": "On PDF load, extract text, images, diagrams, and equations. Use OCR as needed. Generate embeddings via Gemini API and store vector indices locally. Prepare context objects for RAG queries.",
        "testStrategy": "Open various PDFs and confirm extraction of all multimodal elements. Validate embedding generation and local index creation. Test retrieval accuracy for sample queries.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Multimodal Selection and Annotation Tools",
        "description": "Enable users to select text and draw bounding boxes around non-text elements (diagrams, charts, equations) within the PDF viewer.",
        "details": "Implement text highlighting and bounding box drawing tools in the PDF.js layer. Store selection metadata for context passing. Ensure selection UI is intuitive and performant.",
        "testStrategy": "Test selection of text and non-text elements on diverse PDFs. Validate metadata storage and UI responsiveness. Confirm selections trigger downstream actions.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Contextual Chat Sidebar with Strict RAG AI",
        "description": "Develop the chat sidebar that triggers on selection, passes context to Gemini, and strictly grounds responses in the loaded PDF using RAG.",
        "details": "Implement sidebar UI in React. On selection, auto-populate context and invoke Gemini API with strict RAG constraints. Maintain local interaction history per document. Enforce grounding by limiting context to indexed PDF content.",
        "testStrategy": "Select content and trigger chat. Validate context passing, AI response grounding, and local history storage. Test with multimodal selections and verify responses are strictly PDF-based.",
        "priority": "high",
        "dependencies": [
          18,
          19
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Dynamic Study Aid Generation (Summaries, Flashcards, Quizzes)",
        "description": "Allow users to generate study aids (summaries, flashcards, MCQs) for selected scope (page, chapter, document) using Gemini multimodal analysis.",
        "details": "Implement UI for scope selection. Use Gemini to generate brief/detailed summaries, term/definition flashcards, and MCQs with plausible distractors. Enable review, edit, local storage, and export (Anki, CSV) for flashcards. Record quiz results locally.",
        "testStrategy": "Generate study aids for various scopes. Validate output quality, editability, local storage, and export functionality. Test quiz scoring and local result recording.",
        "priority": "high",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Concept Visualization & Simplification Tools",
        "description": "Provide ELI5 explanations and visualization aids (structured text, flowcharts via Mermaid.js) for selected concepts using Gemini.",
        "details": "Add UI options for 'Explain Like I'm Five' and 'Visualize this concept.' Integrate Gemini for simplified explanations and generate Mermaid.js syntax for flowcharts. Render visualizations in sidebar.",
        "testStrategy": "Request ELI5 and visualization for diverse concepts. Validate explanation clarity and visualization rendering. Test Mermaid.js output for correctness.",
        "priority": "medium",
        "dependencies": [
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Local Database Implementation and Analytics",
        "description": "Implement IndexedDB (via Dexie.js) for local storage of learning analytics, event tracking, and knowledge gap analysis.",
        "details": "Set up Dexie.js schema for quiz results, chat queries, flashcards, and topic metadata. Implement event logging and local analytics processing to identify weak concepts. Ensure privacy and offline functionality.",
        "testStrategy": "Simulate user activity and verify data is stored, retrieved, and analyzed locally. Test gap analysis accuracy and dashboard data population. Validate offline access.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Personalized Dashboard and Revision Plan Generation",
        "description": "Build a dashboard UI to display learning statistics, knowledge gaps, and generate personalized revision plans based on local analytics.",
        "details": "Design React dashboard to read from IndexedDB. Visualize quiz performance, chat topics, and weak areas. Implement logic to suggest revision plans and direct users to relevant PDF sections.",
        "testStrategy": "Populate database with sample data and verify dashboard displays correct analytics. Test revision plan generation and navigation to PDF sections.",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Optional Cloud Sync and Clipboard Multimodal Paste",
        "description": "Implement opt-in cloud sync (Firestore) for backup/sync, and multimodal clipboard paste in chat sidebar with privacy controls.",
        "details": "Add UI for cloud sync opt-in and authentication (Firebase). Sync IndexedDB data to Firestore securely. Integrate clipboard paste button in chat sidebar; handle text/image input, send images to Gemini for analysis, and enforce privacy (no default persistence). Provide error handling and offline fallback.",
        "testStrategy": "Enable cloud sync and verify data synchronization. Test clipboard paste for text and images, validate Gemini analysis, and check privacy controls. Simulate offline scenarios and confirm graceful degradation.",
        "priority": "medium",
        "dependencies": [
          24,
          20
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement Multimodal Clipboard Paste in Chat Sidebar",
        "description": "Add a 'Paste from Clipboard' button to the chat sidebar that supports pasting images (PNG/JPEG) and text, handling permissions, privacy, and offline gracefully, and integrates with ChatSidebarService and GeminiAIService.",
        "details": "1. UI: Add a 'Paste from Clipboard' button to the chat sidebar. On click, use the Clipboard API to read clipboard contents. If the clipboard contains an image (PNG/JPEG), display a preview chip in the sidebar and prepare the image as inlineData for the next Gemini multimodal message. If the clipboard contains text, treat it as selected context for chat. \n2. Permissions: Use the asynchronous Clipboard API without requesting persistent permissions; prompt only on user gesture. If clipboard access fails (e.g., due to browser restrictions), fall back to listening for Ctrl/Cmd+V paste events in the chat input. \n3. Error Handling: Show clear, user-friendly messages for permission denials, unsupported formats, or offline status. Ensure all error states are handled gracefully and consistently with the extension's error feedback system. \n4. Privacy: Do not persist pasted images by default; images should be held in memory only for the current chat session unless the user explicitly saves them. \n5. Offline Handling: Detect offline state and disable the paste button or show appropriate messaging. \n6. Service Integration: Extend ChatSidebarService to handle multimodal paste events and wire through to GeminiAIService with a new API method that accepts both text and optional image parts. Ensure the API method can handle both modalities and passes them to Gemini as required. \n7. Unit Tests: Implement unit tests for clipboard handlers (including fallback logic), service entry points, and error handling. Mock clipboard and network conditions to verify all branches. \n8. Documentation: Document the permissions strategy, privacy considerations, and user-facing behaviors for future maintainers.",
        "testStrategy": "- Simulate user clicking the paste button with various clipboard contents (text, PNG, JPEG, unsupported types) and verify correct preview, context handling, and error messages.\n- Test fallback to Ctrl/Cmd+V paste event when Clipboard API is unavailable or denied.\n- Verify that pasted images are not persisted beyond the session unless explicitly saved.\n- Test offline mode: ensure button disables or shows offline messaging, and no clipboard access is attempted.\n- Write unit tests for ChatSidebarService and GeminiAIService entry points, including multimodal API method.\n- Test error handling for permission denial, unsupported formats, and network failures.\n- Confirm all user-facing messages are clear and consistent with extension standards.",
        "status": "done",
        "dependencies": [
          5,
          6,
          14
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add 'Paste from Clipboard' Button to Chat Sidebar UI",
            "description": "Implement a visible and accessible 'Paste from Clipboard' button in the chat sidebar UI, ensuring it matches the design system and is placed for intuitive user access.",
            "dependencies": [],
            "details": "Create a new button component in the chat sidebar. Ensure it is styled according to the sidebar's design guidelines. Add an onClick handler that will trigger clipboard reading logic. The button should be disabled when offline (handled in later subtasks).",
            "status": "done",
            "testStrategy": "Verify button renders correctly, is clickable, and is disabled when offline."
          },
          {
            "id": 2,
            "title": "Implement Clipboard Read Logic for Text and Images",
            "description": "Use the asynchronous Clipboard API to read clipboard contents on button click, supporting both text and image (PNG/JPEG) formats, and fallback to paste event if access fails.",
            "dependencies": [
              "26.1"
            ],
            "details": "On button click, use navigator.clipboard.read() to access clipboard data. Check for image (PNG/JPEG) and text types. If Clipboard API access fails (e.g., permission denied), listen for Ctrl/Cmd+V paste events in the chat input as a fallback. Ensure all clipboard reads are triggered by user gesture.",
            "status": "done",
            "testStrategy": "Simulate clipboard contents with text, PNG, JPEG, and unsupported formats. Test fallback by denying Clipboard API access."
          },
          {
            "id": 3,
            "title": "Display Preview Chip for Pasted Images and Context for Text",
            "description": "Show a preview chip in the sidebar for pasted images and treat pasted text as selected chat context, allowing users to remove or confirm before sending.",
            "dependencies": [
              "26.2"
            ],
            "details": "For images, render a preview chip with a thumbnail and a remove button. Store the image as a Blob in memory for the current session. For text, display it as selected context in the chat input area. Provide UI controls to clear or confirm the pasted content.",
            "status": "done",
            "testStrategy": "Paste images and text, verify correct preview and context display, and test remove/clear actions."
          },
          {
            "id": 4,
            "title": "Handle Permissions, Error States, and Offline Scenarios",
            "description": "Implement robust error handling for permission denials, unsupported formats, and offline status, providing clear user feedback consistent with the extension's error system.",
            "dependencies": [
              "26.2",
              "26.3"
            ],
            "details": "Detect and handle errors from clipboard access (e.g., permission denied, unsupported format). Show user-friendly error messages using the extension's feedback system. Monitor network status to disable the paste button or show offline messaging. Ensure all error states are handled gracefully.",
            "status": "done",
            "testStrategy": "Simulate permission denial, unsupported clipboard formats, and offline state. Verify correct error messages and UI responses."
          },
          {
            "id": 5,
            "title": "Enforce Privacy for Pasted Images and Text",
            "description": "Ensure pasted images are held only in memory for the current chat session and not persisted unless explicitly saved by the user. Apply privacy rules to text context as well.",
            "dependencies": [
              "26.3",
              "26.4"
            ],
            "details": "Store pasted images as Blobs in session memory. Do not write images to disk or persistent storage unless the user chooses to save. For text, ensure it is only used as chat context and not logged or persisted beyond session scope. Document privacy handling in code comments.",
            "status": "done",
            "testStrategy": "Verify images are not persisted after session ends unless saved. Confirm text context is not stored beyond session."
          },
          {
            "id": 6,
            "title": "Integrate Clipboard Paste with ChatSidebarService and GeminiAIService",
            "description": "Extend ChatSidebarService to handle multimodal paste events and wire through to GeminiAIService with a new API method that accepts both text and optional image parts.",
            "dependencies": [
              "26.3",
              "26.5"
            ],
            "details": "Add a method sendMessageWithClipboard({text?, imageBlob?}) to ChatSidebarService. Ensure it packages text and image (as inlineData base64 for images) and passes them to GeminiAIService. Update GeminiAIService to accept and process multimodal requests, handling both modalities as required.",
            "status": "done",
            "testStrategy": "Unit test service methods with various combinations of text and image. Mock GeminiAIService and verify correct API calls."
          },
          {
            "id": 7,
            "title": "Implement Unit Tests for Clipboard Handlers, Services, and Error Handling",
            "description": "Write comprehensive unit tests for clipboard reading logic, fallback mechanisms, service integration, privacy enforcement, and error handling, using mocks for clipboard and network conditions.",
            "dependencies": [
              "26.2",
              "26.3",
              "26.4",
              "26.5",
              "26.6"
            ],
            "details": "Create test cases for: reading clipboard (text/image), fallback to paste event, preview chip rendering, error scenarios, offline handling, privacy rules, and service API integration. Use fake clipboard and blob mocks. Ensure all branches and edge cases are covered.",
            "status": "done",
            "testStrategy": "Run automated tests simulating all clipboard and network conditions. Verify correct UI, service, and privacy behaviors."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-15T20:39:13.643Z",
      "updated": "2025-08-17T18:25:36.639Z",
      "description": "Tasks for master context"
    }
  }
}